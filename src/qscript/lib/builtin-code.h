static const char BUILTIN_CODE[] = "Sequence::all = $$f{\nfor x in this: if !f(x): return false\nreturn true\n}\n\nSequence::any = $$f{\nfor x in this: if f(x): return true\nreturn false;\n}\n\nSequence::none = $$f: !this.any(f)\n\nSequence::find = $$f{\nfor x in this {\nif f(x): return x\n}}\n\nSequence::count = $$f{\nvar count = 0\nfor x in this: if x==f: count+=1\nreturn count\n}\n\nSequence::countIf = $$f{\nvar count = 0\nfor x in this: if f(x): count+=1\nreturn count\n}\n\nSequence::in = $$f{\nfor x in this: if x==f: return true\nreturn false\n}\n\nSequence::first = $$: for i in this: return i\n\nSequence::last = $${\nlet val = null\nfor x in this: val=x\nreturn val\n}\n\nSequence::toList = $$: List.of(this)\nSequence::toTuple = $$: Tuple.of(this)\nSequence::toSet = $$: Set.of(this)\nSequence::toMap = $$: Map.of(this)\n\nlet fThis = $$: this\nList::toList = fThis\nTuple::toTuple = fThis\nSet::toSet = fThis\nMap::toMap = fThis\n\nSequence::map = $$f: f(x) for x in this\n\nSequence::filter = $$f: x for x in this if f(x)\n\nSequence::reduce = $$(f,a){\nfor x in this: a = a==null ? x : f(a,x)\nreturn a\n}\n\nSequence::min = $$(f = $(a,b): a<b?a:b): this.reduce(f)\nSequence::max = $$(f = $(a,b): a>b?a:b): this.reduce(f)\n\nSequence::dropWhile = $$f: $*{\nfor x in this {\nif f(x) break\nyield x\n}}\n\nSequence::skipWhile = $$f: $*{\nvar test = true\nfor x in this {\nif test && f(x) continue\ntest = false\nyield x\n}}\n\nSequence::skip = $$n: $*{\nlet i = 0\nfor x in this {\nif i>=n: yield x\ni+=1\n}}\n\nSequence::limit = $$n: $*{\nlet i=0\nfor x in this {\nif i>=n: break\ni+=1\nyield x\n}}\n\nSequence::enumerate = $$(n=0): $*{\nfor x in this {\nyield (n, x)\nn+=1\n}}\n\nSequence::zipWith = $(...seqs): $*{\nvar iterators = [], keys = [], values = []\nfor seq in seqs { iterators.push(seq.iterator); keys.push(null); values.push(null); }\nwhile true {\nfor i in 0..iterators.length {\nkeys[i] = iterators[i].iterate(keys[i])\nif keys[i]==null {\nreturn null\n}\nvalues[i] = iterators[i].iteratorValue(keys[i])\n}\nlet re = values.toTuple\nyield re\n}\n}\n\nlet fKeys = $$: k for k, v in this,\nfValues = $$: v for k, v in this\nMap::keys = fKeys\nDictionary::keys = fKeys\nMap::values = fValues\nDictionary::values = fValues\n\nlet fGOrC = $$(k,f) {\nlet v = this[k]\nif v==null {\nv = f(k)\nthis[k] = v\n}\nreturn v\n}\nMap::getOrCompute = fGOrC\nDictionary::getOrCompute = fGOrC\n\nlet fFlipped = $$: (v,k) for k, v in this\nMap::flipped = fFlipped\nDictionary::flipped = fFlipped\n";
